# BLE Mesh网络

Ble mesh网络定义了低功耗蓝牙无线技术要实现多对多（many-to-many,m:m）互通的网络规格。当前所阅读的版本为1.0.1。

Ble mesh的docs文档下包含的文件组成：

* [Mesh配置文件](https://github.com/ZoharAndroid/Ble-Mesh/blob/master/docs/Mesh%20profile%20specification%20v1.0.1.pdf)：定义了蓝牙低功耗无线技术要实现具有互通性的mesh网络解决方案所满足的基本要求。
* [Mesh模型](https://github.com/ZoharAndroid/Ble-Mesh/blob/master/docs/Mesh%20Model%20Specification%20v1.0.1.pdf)：介绍了模型，与其用于定义mesh网络中节点的基本功能。
* [Mesh设备属性](https://github.com/ZoharAndroid/Ble-Mesh/blob/master/docs/Mesh%20Device%20Properties%20v1.0.pdf)：定义了mesh模型规格所需的设备属性。
---

**Mesh配置文件内容：**

# 1 Mesh系统结构

## 1.1 Mesh分层体系结构

![](https://github.com/ZoharAndroid/MarkdownImages/blob/master/2019-3-25/mesh%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png?raw=true)

### 1.1.1 Model层

模型层定义用于标准化典型用户场景操作的模型，并在蓝牙网格模型规范或其他更高层规范中定义。更高层模型规范的例子包括照明和传感器的模型。

### 1.1.2 Foundation Model layer（基础模型层）

基础模型层定义了配置和管理网状网络所需的状态、消息和模型。

### 1.1.3 Access层（访问层）

访问层定义了上层应用程序如何使用上层传输层。它定义应用程序数据的格式；它定义和控制在上层传输层中执行的应用程序数据加密和解密；在将数据转发到上层之前，它检查传入的应用程序数据是否在正确的网络和应用程序密钥的上下文中被接收。

### 1.1.4 Upper transport layer（上层传输层）

上层传输层对应用程序数据进行加密，解密和验证，旨在提供访问消息的机密性。 它还定义了如何使用传输控制消息来管理节点之间的上层传输层，包括何时由Friend功能使用。

### 1.1.5 Lower transport layer（下层传输层）

下传输层定义了如何将上传输层消息分割并重新组装成多个下传输PDU，以便将较大的上传输层消息传递给其他节点。它还定义了一个单独的控制消息来管理分段和重新组装。

### 1.1.6 Network layer（网络层）

网络层定义如何将传输消息寻址到一个或多个元素。 它定义了允许传输PDU由承载层传输的网络消息格式。网络层决定是中继/转发消息，接受它们以进行进一步处理，还是拒绝它们。 它还定义了如何加密和验证网络消息。

### 1.1.7 Bearer layer（承载层）

承载层定义了如何在节点之间传输网络消息。 定义了两个承载，即广告承载和GATT承载。 可能会在将来定义其他承载。

## 1.2 Mesh操作概述

本规范定义的Mesh网络操作旨在：

* 使消息能够从一个元素发送到一个或多个元素;
* 允许通过其他节点中继消息以扩展通信范围;
* 针对已知安全攻击的安全消息，包括窃听攻击、中间人攻击、重放攻击、垃圾桶攻击、暴力破解密钥攻击以及此处未记录的可能的其他安全攻击；
* 在当今市场上的现有设备上工作;
* 及时传递信息;
* 当一个或多个设备移动或停止运行时继续工作；以及
* 具有内置的前向兼容性，以支持未来版本的Mesh配置文件规范。

该规范定义了基于托管洪泛的网状网络，该网络使用广播信道来发送消息，以便其他节点可以接收消息并转发这些消息; 从而扩展了原始信息的范围。 只要有足够密度的设备正在侦听和转发消息，托管洪泛网状网络中的任何设备都可以随时发送消息。 添加路由功能和定义基于路由的网状网络的增强可以考虑用于该规范的未来修订。

本规范使用许多方法来限制托管洪泛网状网络中的消息的无限中继。 使用的两种主要方法是网络消息缓存方法和生存时间方法。

网络消息高速缓存旨在通过将所有消息添加到高速缓存列表来防止设备中继先前接收的消息。 收到消息后，将根据列表对其进行检查，如果已存在则忽略该消息。 如果尚未收到，则将其添加到缓存中，以便将来可以忽略它。 为防止此列表变得太长，缓存的消息数量受实现限制。

每条消息都包含一个生存时间（TTL）值，用于限制消息可以被中继的次数。 每次接收消息然后由设备中继（最多126次）时，TTL值减1。

### 1.2.1 网络和子网

Mesh网络由共享四个公共资源的节点组成：

* 用于识别消息来源和目的地的网络地址（参见第3.4.2节）;
* 用于在网络层保护和验证消息的网络密钥（见第3.8.6.3节）
* 用于在访问层保护和验证消息的应用程序密钥（参见第3.8.6.2节）; 
* 用于延长网络寿命的IV索引（见第3.8.4节）。

一个网络可以有一个或多个子网，以便于“区域”隔离（例如，酒店网络中的隔离酒店房间子网）。子网是一组节点，它们可以在网络层上相互通信，因为它们共享一个网络密钥。通过知道一个或多个网络密钥，一个节点可以属于一个或多个子网。配置时，设备被配置到一个子网，并可以使用配置模型添加到更多子网。

有一个称为主子网的特殊子网，它基于主NetKey（参见第3.8.6.4节）。 主子网上的节点参与IV更新过程（请参阅第3.10.5节），并将IV更新传播到其他子网，而其他子网上的节点仅将IV索引更新传播到这些子网。

网络资源由实现配置客户机模型的节点管理，称为配置客户机（通常是智能电话或其他移动计算设备），并在配置时使用配置服务器模型（见第4.4.1节）分配给节点（见第5节）。特别是，设置程序管理地址分配，以确保没有分配重复的单播地址，而配置客户机生成并分发网络和应用程序密钥，并确保需要相互通信的设备共享网络和访问层的正确密钥。配置客户机还知道设备密钥（见第3.8.6.1节），用于确保与每个节点的通信安全，包括分发更新的网络和应用程序密钥。

### 1.2.2 设备和节点

不是网状网络成员的设备称为未设置的设备。 作为网状网络成员的设备称为节点。 供应者用于管理未设置的设备和节点之间的转换。

未设置的设备无法发送或接收网状消息; 然而，它将其存在广告给Provisioner。 在经过身份验证后，Provisioner将邀请未设置的设备进入网状网络，将未设置的设备转换为节点。

### 1.2.3 添加设备到mesh网络

设备由Provisioner添加到网状网络，此时它们成为节点。 将设备提供到网状网络中与通常在蓝牙无线技术中使用的点对点绑定和配对不同。 使用简单的广告承载或基于点对点GATT的承载来实现设备的供应。 在两个承载上使用单个供应协议。 基于广告的承载的供应由所有设备实现。 通过基于GATT的承载进行供应允许诸如传统电话之类的设备（即，不支持通过广告承载本地供应的设备）是供应商。

为了帮助配置多个设备，设备具有可由配置器设置的注意定时器。 设置为非零值时，设备会使用任何方法识别自身。 例如，设备可以闪光，发出声音或振动。 当注意力计时器到期时，设备停止识别自身。 这允许Provisioner向设备发送单个消息以使其识别自身，并且设备在给定时间后自动停止识别自身。

### 1.2.4 通信支持

许多当前设备无法在不更新的情况下通告或理解网状消息。 为了使这些设备能够与网状网络中的节点通信而无需操作系统更新或类似的硬件/软件更新，该规范允许对所有现有设备使用gatt连接。

### 1.2.5 低功耗支持

该规范中的特征使得网状网络中的许多设备能够由电池供电或者使用诸如能量收集之类的技术。 这些设备可能受限于它们如何用作网状网络的一部分（例如，仅在与之交互时发送数据的设备）。 该规范不要求设备在每个连接上协调传输，建立连接或重新启动安全性; 从而促进低功率操作。 需要低功耗支持的设备可以使用称为友谊的概念将自己与代表他们存储和转发消息的永远在线设备关联起来（参见第3.6.6节）。 然而，在大多数情况下，中继消息的设备将接收消息以及转发消息，并且可能比典型的小型电池或电容器提供的功率大得多。

## 1.3 体系慨念

网状网络体系结构使用几种不同的概念：状态，消息，绑定，元素，寻址，模型，发布 - 订阅，网格密钥和关联。

### 1.3.1 状态

状态是表示元素条件的值。

**公开状态的元素称为服务器**。例如，最简单的服务器是一个通用的ONOFF服务器，表示它是打开还是关闭。

**访问状态的元素称为客户端**。 例如，最简单的客户端是通用OnOff客户端（二进制交换机），它能够通过Generic OnOff模型定义的消息控制通用OnOff服务器

**由两个或多个值组成的状态称为复合状态**。 例如，换色灯可以与色彩饱和度和亮度分开控制色调。

### 1.3.2 绑定状态

当一个状态被绑定到另一个状态时，一个状态的变化会导致另一个状态的变化。 绑定状态可以来自一个或多个元素中的不同模型。 例如，常见的绑定类型在Level状态和OnOff状态之间：将Level更改为0会将绑定的OnOff状态更改为Off，将Level更改为非零值会将绑定的OnOff状态更改为On。

### 1.3.3 消息

网状网络内的所有通信都是通过发送消息来完成的。 消息在状态下运行。 对于每个状态，存在服务器支持的定义的消息集，并且客户端可以使用该消息来请求状态的值或改变状态。 服务器还可以发送携带有关状态和/或改变状态的信息的未经请求的消息。

消息被定义为具有操作码，相关参数和行为。 操作码可以是单个八位字节（对于需要最大可能的参数有效载荷的特殊消息），2个八位字节（对于标准消息）或3个八位字节（对于特定于供应商的消息）。

包括操作码的总消息大小由底层传输层确定，其可以使用分段和重组（SAR）机制。 为了最大限度地提高性能并避免SAR的开销，设计目标是将消息放在单个段中。 传输层为非分段消息提供多达11个八位字节，当使用1个八位字节操作码时，最多可提供10个八位字节，当使用2个八位字节操作码时，最多可提供9个八位字节参数，以及 使用供应商特定的3个八位字节操作码时，可用于8个八位字节的参数。

传输层提供了一种能够传输多达32个段的SAR机制。 使用SAR时的最大消息大小为384个八位字节。 这意味着（不包括应用MIC）当使用1个八位字节操作码时，最多379个八位字节可用于参数，当使用2个八位字节操作码时，最多378个八位字节可用于参数，当参数时可用于参数最多377个八位字节 使用特定于供应商的3个八位字节操作码。

### 1.3.4 元素

元素是节点内的可寻址实体。 每个节点具有至少一个元素，即主要元素，并且可以具有一个或多个附加的次要元素。 元素的数量和结构是静态的，并且在节点的整个生命周期中都不会改变（即，只要节点是网络的一部分）。

使用在配置期间分配给节点的第一个单播地址来寻址主要元素。 使用后续地址寻址每个附加次要元素。 这些单播元素地址允许节点识别节点内的哪个元素正在发送或接收消息。

如果元素的数量和结构发生变化（例如由于固件更新），则必须重新配置节点。 当执行固件更新以更改元素的数量或结构时，将使用节点删除过程（请参阅第3.10.7节）。

### 1.3.5 地址

地址可以是单播地址，虚拟地址或组地址。 还有一个特殊值表示未在消息中使用的未分配地址。

单播地址分配给元素，并始终表示节点的单个元素。 每个网状网络有32767个单播地址。

**虚拟地址是多播地址**，可以表示一个或多个节点上的多个元素。 每个虚拟地址在逻辑上代表一个标签UUID，它是一个128位值，无需集中管理。 发送到Label UUID的每条消息都包含消息完整性检查值中的完整标签UUID，用于验证消息。 为了减少检查每个已知Label UUID的开销，使用Label UUID的散列。 有16384个哈希值，每个哈希值都编码一组虚拟地址。 虽然虚拟地址中只使用了16384个哈希值，但每个哈希值可以表示数百万个可能的标签UUID; 因此，虚拟地址的数量被认为非常大。

组地址是多播地址，可以表示一个或多个节点上的多个元素。 每个网状网络有16384个组地址。 存在一组固定组地址，用于基于那些节点的功能来寻址节点的所有主要元素的子集。 所有其他组地址称为动态分配的组地址。 有256个固定组地址和16128个动态分配的组地址。

### 1.3.6 模型

模型定义节点的基本功能。 节点可以包括多个模型。 模型定义了所需的状态（如第2.3.1节所述），作用于这些状态的消息（如第2.3.3节所述）以及任何相关的行为。

此规范定义了三种类型的模型：服务器模型，客户端模型和控制模型：

* 服务器模型：服务器模型由跨越一个或多个元素的一个或多个状态组成。 服务器模型定义了它可以发送或接收的一组强制消息，元素在发送和接收此类消息时所需的行为，以及在发送或接收消息之后发生的任何其他行为。
* 客户端模型：客户端模型定义客户端用于请求，更改或使用服务器模型定义的相应服务器状态的一组消息（强制和可选）。 客户端模型没有状态。
* 控制模型：控制模型可以包含与其他服务器模型通信的客户端模型功能和与其他客户端模型通信的服务器模型功能。 控制模型还可以包含控制逻辑，控制逻辑是一组规则和行为，其协调控制模型连接到的其他模型之间的交互。

消息可以由多个不同的模型使用。 消息行为在每个模型中都是相同的，从而实现客户端，服务器和控制模型之间的共同理解，因为无论发送和处理消息的模型如何，行为都是一致的。

型号规格设计得非常小且独立。 在规范定义时，模型可以要求必须在同一节点内实例化的其他模型。 这称为扩展，这意味着模型可以扩展其他模型。

不扩展其他模型的模型称为根模型。

模型规范是不可变的：无法移除或向模型添加行为，无论所需行为是可选行为还是必需行为。 模型没有版本，没有功能位。 如果模型中需要其他行为，则定义新的扩展模型，该模型公开所需的行为，并且可以与原始模型一起实现。

因此，元素支持的模型的知识决定了该元素所暴露的确切行为。

模型可以由蓝牙签名定义和采用，并且可以由供应商定义。 蓝牙sig定义的模型称为sig采用的模型，供应商定义的模型称为供应商模型。 模型由唯一标识符标识，对于sig采用的模型，可以是16位，对于供应商模型，可以是32位。

### 1.3.9 安全

使用两种类型的密钥对所有消息进行加密和验证。 一种密钥类型用于网络层通信，使得网状网络内的所有通信将使用相同的网络密钥。 另一种密钥类型是应用程序数据。 分离用于联网和应用的密钥允许敏感的访问消息（例如，用于对建筑物的访问控制）与非敏感的访问消息（例如，用于照明）分离。 网状网络中没有未加密或未经验证的消息。

#### 1.3.9.1 应用和网络安全

在上层传输层和网络层加密和验证消息旨在保护网状网络内的通信免受窃听者和恶意攻击。 每个层维护不同的密钥，以允许应用程序和网络实体之间的分离

从网络密钥拆分应用程序密钥可以实现应用程序消息的安全中继传输：中继节点可以在网络级别验证消息，而无需访问应用程序数据。 例如，用作中继节点的灯泡不应该能够解锁门。

这意味着节点可以使用从网络密钥派生的密钥来中继访问消息，而无需知道应用程序密钥; 因此，他们无法更改或理解应用程序数据。 预期网络密钥将被网络内的许多节点广泛知晓，从而增加中继节点的密度，同时保护不同的应用区域彼此。 这需要每个应用程序单独的键。 例如，敏感门安全应用将与非敏感门铃和照明应用分开。

应用程序密钥与在某些上下文中使用的关联应用程序密钥标识符一起直接使用，以标识所使用的应用程序。 但是，网络密钥始终通过密钥派生函数来使用，以生成直接使用的其他密钥。 这些密钥的示例包括加密和隐私密钥。 这允许更改单个网络密钥，并且可以快速导出从该密钥派生的所有关联值。 与应用程序密钥一样，网络密钥也用于导出网络密钥标识符（请参阅第3.8.6节）。

安全模型定义了三个单独的密钥（设备密钥（devkey），应用程序密钥（appkey）和网络密钥（netkey））来保护消息。 当给节点一个密钥时，它被授权使用该密钥。 在多个节点之间共享的密钥允许具有该密钥的任何节点使用该密钥发送和接收消息。

设备密钥有助于配置客户端和单个节点之间的密钥材料的机密性和认证。 应用程序密钥有助于在预期节点之间发送的应用程序数据的机密性和身份验证。 网络密钥有助于网络消息的隐私性，机密性和真实性。 节点可以知道单个设备密钥，多个应用密钥和多个网络密钥。

应用程序密钥只能与单个网络密钥一起使用。 这意味着网络密钥具有与之关联的一个或多个应用程序密钥。 这种关联被称为键绑定。